#!raku

use Test;
use Log::Async;
use Samaki::Plugin::Repl::Raku;

if %*ENV<TEST_VERBOSE> {
  logger.add-tap: -> $m { diag $m<msg>; };
}

if %*ENV<SAMAKI_TEST_REPL> {
  plan 6;
} else {
  plan :skip-all<Set SAMAKI_TEST_REPL environment variable to run this test>;
}

my $p = Samaki::Plugin::Repl::Raku.new;

my @out;
$p.^find_method('stream').wrap: -> |args { @out.push: args }
my $cell = Samaki::Cell.new:
  page-name => 'test', cell-type => 'test', name => 'test', data-dir => $*TMPDIR, wkdir => $*TMPDIR,
  content => "say 'hello world';",
  plugin => $p;
  ;

$p.execute(:$cell, :mode<raw>);

# Wait for REPL to start, process input, and produce output
my $max-wait = 10;
my $waited = 0;
while @out.elems < 7 && $waited < $max-wait {
  sleep 0.5;
  $waited += 0.5;
}

my $found;
for @out {
  $found = True if .[1].Str.contains('hello world');
}

ok $found, 'found hello world in output';

# Test 2: Execute another command in the same REPL session
my $cell2 = Samaki::Cell.new:
  page-name => 'test', cell-type => 'test', name => 'test2', data-dir => $*TMPDIR, wkdir => $*TMPDIR,
  content => "my \$x = 42; say \$x;",
  plugin => $p;
@out = ();
$p.execute(:cell($cell2), :mode<raw>);

$waited = 0;
while @out.elems < 2 && $waited < $max-wait {
  sleep 0.5;
  $waited += 0.5;
}

$found = False;
for @out {
  $found = True if .[1].Str.contains('42');
}
ok $found, 'second command executed in same session';

# Test 3: Variable persists across executions
my $cell3 = Samaki::Cell.new:
  page-name => 'test', cell-type => 'test', name => 'test3', data-dir => $*TMPDIR, wkdir => $*TMPDIR,
  content => "say \$x * 2;",
  plugin => $p;
@out = ();
$p.execute(:cell($cell3), :mode<raw>);

$waited = 0;
while @out.elems < 2 && $waited < $max-wait {
  sleep 0.5;
  $waited += 0.5;
}

$found = False;
for @out {
  $found = True if .[1].Str.contains('84');
}
ok $found, 'variables persist across executions';

# Test 4: Multi-line input
my $cell4 = Samaki::Cell.new:
  page-name => 'test', cell-type => 'test', name => 'test4', data-dir => $*TMPDIR, wkdir => $*TMPDIR,
  content => "for 1..3 -> \$i \{\n  say \"line \$i\";\n}",
  plugin => $p;
@out = ();
$p.execute(:cell($cell4), :mode<raw>);

$waited = 0;
while @out.elems < 5 && $waited < $max-wait {
  sleep 0.5;
  $waited += 0.5;
}

my $count = 0;
for @out {
  $count++ if .[1].Str.contains('line');
}
ok $count >= 3, 'multi-line input produces multiple outputs';

# Test 5: Expression evaluation
my $cell5 = Samaki::Cell.new:
  page-name => 'test', cell-type => 'test', name => 'test5', data-dir => $*TMPDIR, wkdir => $*TMPDIR,
  content => "2 + 2",
  plugin => $p;
@out = ();
$p.execute(:cell($cell5), :mode<raw>);

$waited = 0;
while @out.elems < 2 && $waited < $max-wait {
  sleep 0.5;
  $waited += 0.5;
}

$found = False;
for @out {
  $found = True if .[1].Str.contains('4');
}
ok $found, 'expression evaluation works';

$p.shutdown;

ok 1, 'process exited';

# Diagnostic information for debugging GitHub Actions timeouts
diag "=== Post-test diagnostics ===";

# Check script command availability
diag "Checking script command...";
my $script-check = run 'script', '--version', :out, :err;
if $script-check.exitcode == 0 {
  diag "script version: {$script-check.out.slurp(:close).lines.head}";
} else {
  diag "script command check failed";
}

diag "Checking for lingering processes...";
my $ps-proc = run 'ps', 'aux', :out;
my $ps-output = $ps-proc.out.slurp(:close);
my @lines = $ps-output.lines.grep: /script|raku.*repl/;
if @lines {
  diag "Found {+@lines} REPL-related processes:";
  for @lines -> $line {
    diag "  $line";
  }
} else {
  diag "No lingering REPL processes found";
}

diag "Checking open file descriptors for this process (PID: $*PID)...";
try {
  my $lsof-proc = run 'lsof', '-p', ~$*PID, :out, :err;
  if $lsof-proc.exitcode == 0 {
    my $lsof-output = $lsof-proc.out.slurp(:close);
    my @fds = $lsof-output.lines;
    diag "Open file descriptors: {+@fds}";
    for @fds.head(20) -> $line {
      diag "  $line";
    }
    if +@fds > 20 {
      diag "  ... and {+@fds - 20} more";
    }
  } else {
    diag "lsof returned non-zero exit code";
  }
  CATCH {
    default {
      diag "lsof not available or failed: {.message}";
    }
  }
}

diag "=== End diagnostics ===";

